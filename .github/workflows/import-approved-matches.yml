name: Import approved matches (CSV → DB, Barbora)

on:
  workflow_dispatch:
    inputs:
      run_set:
        description: "Which CSVs to import"
        type: choice
        options: [all, rimi, selver, prisma]
        default: all
      right_chain:
        description: "RIGHT/target chain label"
        required: true
        default: "Barbora"

jobs:
  import:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include:
          - slug: rimi
            left_chain: Rimi
            csv_path: data/approved_rimi_matches.csv
          - slug: selver
            left_chain: Selver
            csv_path: data/approved_selver_matches.csv
          - slug: prisma
            left_chain: Prisma
            csv_path: data/approved_prisma_matches.csv

    steps:
      - name: Checkout
        if: ${{ github.event.inputs.run_set == 'all' || github.event.inputs.run_set == matrix.slug }}
        uses: actions/checkout@v4

      - name: Ensure CSV exists
        if: ${{ github.event.inputs.run_set == 'all' || github.event.inputs.run_set == matrix.slug }}
        shell: bash
        env:
          INPUT_CSV_PATH: ${{ matrix.csv_path }}
        run: |
          set -euo pipefail
          CSV_PATH="$GITHUB_WORKSPACE/$INPUT_CSV_PATH"
          echo "Checking CSV at: $CSV_PATH"
          test -f "$CSV_PATH" || { echo "CSV not found at: $CSV_PATH"; exit 1; }
          head -n 5 "$CSV_PATH" || true

      - name: Install tools
        if: ${{ github.event.inputs.run_set == 'all' || github.event.inputs.run_set == matrix.slug }}
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y postgresql-client python3

      - name: Normalize CSV → /tmp/normalized.csv (left_chain,left_key,right_chain,right_key,note,approved_by)
        if: ${{ github.event.inputs.run_set == 'all' || github.event.inputs.run_set == matrix.slug }}
        shell: bash
        env:
          INPUT_CSV_PATH: ${{ matrix.csv_path }}
          INPUT_LEFT_CHAIN: ${{ matrix.left_chain }}
          INPUT_RIGHT_CHAIN: ${{ github.event.inputs.right_chain }}
        run: |
          set -euo pipefail
          CSV_IN="$GITHUB_WORKSPACE/$INPUT_CSV_PATH"
          CSV_OUT="/tmp/normalized.csv"
          PY="/tmp/normalize_matches.py"
          : > "$PY"

          # Python script (echo-based; YAML-safe)
          echo 'import csv, os, re, sys' >> "$PY"
          echo 'csv_in = os.environ["CSV_IN"]' >> "$PY"
          echo 'csv_out = os.environ["CSV_OUT"]' >> "$PY"
          echo 'LEFT = os.environ["INPUT_LEFT_CHAIN"]' >> "$PY"
          echo 'RIGHT = os.environ["INPUT_RIGHT_CHAIN"]' >> "$PY"
          echo 'def lower(xs): return [x.strip().lower() for x in xs]' >> "$PY"
          echo 'def find_exact(headers, names):' >> "$PY"
          echo '    h = lower(headers)' >> "$PY"
          echo '    for n in names:' >> "$PY"
          echo '        if n in h: return h.index(n)' >> "$PY"
          echo '    return None' >> "$PY"
          echo 'def find_contains(headers, subs):' >> "$PY"
          echo '    h = lower(headers)' >> "$PY"
          echo '    for i,name in enumerate(h):' >> "$PY"
          echo '        for s in subs:' >> "$PY"
          echo '            if s in name: return i' >> "$PY"
          echo '    return None' >> "$PY"
          echo 'ean_re = re.compile(r"^[0-9]{8,14}$")' >> "$PY"
          echo 'with open(csv_in, "r", encoding="utf-8-sig", newline="") as f:' >> "$PY"
          echo '    r = csv.reader(f)' >> "$PY"
          echo '    headers = next(r)' >> "$PY"
          echo '    Hlow = [h.strip().lower() for h in headers]' >> "$PY"
          echo '    # LEFT key' >> "$PY"
          echo '    left_idx = find_exact(headers, ["left_key","left_id","left_product_id","left_hash","source_id","source_key","rimi_id","selver_id","prisma_id"])' >> "$PY"
          echo '    if left_idx is None: left_idx = 0' >> "$PY"
          echo '    # RIGHT key: prefer Barbora id names, then generic right_*, then any header containing "barbora", else ean/gtin/barcode, else scan row' >> "$PY"
          echo '    right_idx = find_exact(headers, ["barbora_id","barbora_product_id","barbora_sku","barbora_code"])' >> "$PY"
          echo '    if right_idx is None: right_idx = find_exact(headers, ["right_key","right_id","right_product_id","target_id","target_product_id","product_b_id","product_id"])' >> "$PY"
          echo '    if right_idx is None: right_idx = find_contains(headers, ["barbora"])' >> "$PY"
          echo '    if right_idx is None: right_idx = find_contains(headers, ["ean","gtin","barcode"])' >> "$PY"
          echo '    note_i = next((Hlow.index(x) for x in ("note","notes","comment","comments","match_strength","strength") if x in Hlow), None)' >> "$PY"
          echo '    by_i   = next((Hlow.index(x) for x in ("approved_by","approver","user","author") if x in Hlow), None)' >> "$PY"
          echo '    total=0; kept=0; empty_right=0' >> "$PY"
          echo '    with open(csv_out, "w", encoding="utf-8", newline="") as g:' >> "$PY"
          echo '        w = csv.writer(g); w.writerow(["left_chain","left_key","right_chain","right_key","note","approved_by"])' >> "$PY"
          echo '        for row in r:' >> "$PY"
          echo '            total += 1' >> "$PY"
          echo '            if not row: continue' >> "$PY"
          echo '            if len(row) < len(headers): row += [""]*(len(headers)-len(row))' >> "$PY"
          echo '            left_key = row[left_idx].strip() if left_idx < len(row) else ""' >> "$PY"
          echo '            right_key = ""' >> "$PY"
          echo '            if right_idx is not None and right_idx < len(row): right_key = row[right_idx].strip()' >> "$PY"
          echo '            if not right_key:' >> "$PY"
          echo '                for val in reversed(row):' >> "$PY"
          echo '                    v = val.strip();' >> "$PY"
          echo '                    if ean_re.match(v): right_key = v; break' >> "$PY"
          echo '            note = row[note_i].strip() if (note_i is not None and note_i < len(row)) else ""' >> "$PY"
          echo '            by   = row[by_i].strip()   if (by_i   is not None and by_i   < len(row)) else ""' >> "$PY"
          echo '            if left_key and right_key:' >> "$PY"
          echo '                kept += 1; w.writerow([LEFT, left_key, RIGHT, right_key, note, by])' >> "$PY"
          echo '            else:' >> "$PY"
          echo '                if not right_key: empty_right += 1' >> "$PY"
          echo '    fill = (kept/total) if total else 0.0' >> "$PY"
          echo '    print(f"[normalize] rows_in={total} rows_out={kept} empty_right={empty_right} fill_rate={fill:.3f}", file=sys.stderr)' >> "$PY"
          echo '    if total and (kept/total) < 0.90: sys.exit(2)' >> "$PY"

          env CSV_IN="$CSV_IN" CSV_OUT="$CSV_OUT" python3 "$PY"
          echo "Normalized preview:"; head -n 8 "$CSV_OUT" || true

      - name: Import normalized CSV → approved_matches_active (dedupe + upsert)
        if: ${{ github.event.inputs.run_set == 'all' || github.event.inputs.run_set == matrix.slug }}
        shell: bash
        env:
          DATABASE_URL_PUBLIC: ${{ secrets.DATABASE_URL_PUBLIC }}
          DATABASE_URL:        ${{ secrets.DATABASE_URL }}
          PGHOST:              ${{ secrets.PGHOST }}
          PGPORT:              ${{ secrets.PGPORT }}
          PGUSER:              ${{ secrets.PGUSER }}
          PGPASSWORD:          ${{ secrets.PGPASSWORD }}
          PGDATABASE:          ${{ secrets.PGDATABASE }}
          INPUT_LEFT_CHAIN:    ${{ matrix.left_chain }}
        run: |
          set -euo pipefail
          DB_URL="${DATABASE_URL_PUBLIC:-${DATABASE_URL:-}}"
          if [[ -z "$DB_URL" ]]; then
            DB_URL="postgresql://$PGUSER:$PGPASSWORD@$PGHOST:$PGPORT/$PGDATABASE"
          fi
          [[ "$DB_URL" == *"sslmode="* ]] || DB_URL="${DB_URL}?sslmode=require"

          echo "== Connectivity check ==" && psql "$DB_URL" -Atc "select current_database();" >/dev/null

          SQL="/tmp/import_matches.sql"; : > "$SQL"
          {
            echo '\set ON_ERROR_STOP on'
            echo 'BEGIN;'
            echo 'CREATE TABLE IF NOT EXISTS approved_matches_active ('
            echo '  left_chain  text NOT NULL,'
            echo '  left_key    text NOT NULL,'
            echo '  right_chain text NOT NULL,'
            echo '  right_key   text NOT NULL,'
            echo '  note        text,'
            echo '  approved_by text,'
            echo '  approved_at timestamptz NOT NULL DEFAULT now(),'
            echo '  PRIMARY KEY (left_chain, left_key)'
            echo ');'
            echo 'DROP TABLE IF EXISTS approved_matches_import;'
            echo 'CREATE TEMP TABLE approved_matches_import ('
            echo '  left_chain  text,'
            echo '  left_key    text,'
            echo '  right_chain text,'
            echo '  right_key   text,'
            echo '  note        text,'
            echo '  approved_by text'
            echo ');'
            echo "\\copy approved_matches_import (left_chain,left_key,right_chain,right_key,note,approved_by) FROM '/tmp/normalized.csv' CSV HEADER;"
            echo ''
            echo '-- Dedupe per (left_chain,left_key) so ON CONFLICT can run once per row'
            echo 'WITH dedup AS ('
            echo '  SELECT left_chain,left_key,right_chain,right_key,'
            echo '         max(note) AS note, max(approved_by) AS approved_by,'
            echo '         row_number() OVER (PARTITION BY left_chain,left_key ORDER BY right_key DESC, note DESC) AS rn'
            echo '  FROM approved_matches_import'
            echo '  GROUP BY left_chain,left_key,right_chain,right_key'
            echo ')'
            echo 'INSERT INTO approved_matches_active (left_chain,left_key,right_chain,right_key,note,approved_by)'
            echo 'SELECT left_chain,left_key,right_chain,right_key,note,approved_by'
            echo 'FROM dedup WHERE rn = 1'
            echo 'ON CONFLICT (left_chain,left_key) DO UPDATE'
            echo '  SET right_chain = EXCLUDED.right_chain,'
            echo '      right_key   = EXCLUDED.right_key,'
            echo '      note        = COALESCE(EXCLUDED.note, approved_matches_active.note),'
            echo '      approved_by = COALESCE(EXCLUDED.approved_by, approved_matches_active.approved_by),'
            echo '      approved_at = now();'
            echo 'COMMIT;'
            echo ""
            echo "SELECT '${INPUT_LEFT_CHAIN}'::text AS left_chain, COUNT(*) AS rows FROM approved_matches_active WHERE left_chain = '${INPUT_LEFT_CHAIN}';"
          } >> "$SQL"

          echo "=== Executing SQL for ${INPUT_LEFT_CHAIN} ==="
          psql "$DB_URL" -f "$SQL"

      - name: Show sample rows
        if: ${{ github.event.inputs.run_set == 'all' || github.event.inputs.run_set == matrix.slug }}
        shell: bash
        env:
          DATABASE_URL_PUBLIC: ${{ secrets.DATABASE_URL_PUBLIC }}
          DATABASE_URL:        ${{ secrets.DATABASE_URL }}
          PGHOST:              ${{ secrets.PGHOST }}
          PGPORT:              ${{ secrets.PGPORT }}
          PGUSER:              ${{ secrets.PGUSER }}
          PGPASSWORD:          ${{ secrets.PGPASSWORD }}
          PGDATABASE:          ${{ secrets.PGDATABASE }}
          INPUT_LEFT_CHAIN:    ${{ matrix.left_chain }}
        run: |
          set -euo pipefail
          DB_URL="${DATABASE_URL_PUBLIC:-${DATABASE_URL:-}}"
          if [[ -z "$DB_URL" ]]; then
            DB_URL="postgresql://$PGUSER:$PGPASSWORD@$PGHOST:$PGPORT/$PGDATABASE"
          fi
          [[ "$DB_URL" == *"sslmode="* ]] || DB_URL="${DB_URL}?sslmode=require"
          psql "$DB_URL" -c "SELECT * FROM approved_matches_active WHERE left_chain = '${INPUT_LEFT_CHAIN}' ORDER BY left_key LIMIT 25;"
