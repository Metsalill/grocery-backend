name: "Import approved matches to Railway (Rimi/Selver/Prisma)"

on:
  workflow_dispatch:
    inputs:
      csv_dir:
        description: "Directory in repo containing approved_*.csv files"
        required: true
        default: "data"

jobs:
  import:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Install psql client
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client

      - name: Prepare DATABASE_URL (public) with sslmode=require
        id: prep
        env:
          DBURL_PUBLIC: ${{ secrets.DATABASE_URL_PUBLIC }}
          DBURL: ${{ secrets.DATABASE_URL }}
        shell: bash
        run: |
          set -euo pipefail
          URL="${DBURL_PUBLIC:-$DBURL}"
          if [[ -z "${URL}" ]]; then
            echo "No DATABASE_URL_PUBLIC or DATABASE_URL secret set." >&2
            exit 1
          fi
          if [[ "$URL" == *"?"* ]]; then
            case "$URL" in
              *"sslmode="*) : ;;
              *) URL="${URL}&sslmode=require" ;;
            esac
          else
            URL="${URL}?sslmode=require"
          fi
          echo "url=$URL" >> "$GITHUB_OUTPUT"

      - name: Create table + indexes (if not exists)
        env:
          DATABASE_URL: ${{ steps.prep.outputs.url }}
        shell: bash
        run: |
          set -euo pipefail
          psql "$DATABASE_URL" -v ON_ERROR_STOP=1 <<'PSQL'
          CREATE TABLE IF NOT EXISTS approved_matches (
            barbora_uid    text NOT NULL,
            barbora_name   text,
            barbora_brand  text,
            barbora_size   text,
            match_uid      text NOT NULL,
            match_name     text,
            match_brand    text,
            match_size     text,
            match_ean      text,
            store          text NOT NULL,
            similarity     numeric(5,4),
            size_diff_pct  numeric(6,2),
            tier           text,
            is_best_match  boolean,
            reviewed_at    timestamptz DEFAULT now(),
            PRIMARY KEY (barbora_uid, store, match_uid)
          );

          CREATE INDEX IF NOT EXISTS idx_approved_matches_barbora_uid ON approved_matches (barbora_uid);
          CREATE INDEX IF NOT EXISTS idx_approved_matches_store_match_uid ON approved_matches (store, match_uid);

          CREATE OR REPLACE VIEW approved_best_match_per_store AS
          SELECT DISTINCT ON (barbora_uid, store)
                 barbora_uid, store, match_uid, match_ean,
                 similarity, tier, is_best_match,
                 barbora_name, barbora_brand, barbora_size,
                 match_name, match_brand, match_size
          FROM approved_matches
          ORDER BY barbora_uid, store, is_best_match DESC, similarity DESC, tier ASC, match_uid;
          PSQL

      - name: Import approved matches (Selver, Rimi, Prisma)
        env:
          DATABASE_URL: ${{ steps.prep.outputs.url }}
          CSV_DIR: ${{ github.event.inputs.csv_dir }}
        shell: bash
        run: |
          set -euo pipefail

          import_one () {
            local f="$1"
            if [[ -f "$f" ]]; then
              echo "Importing $f"
              # Use an unquoted heredoc so $f expands inside \copy
              psql "$DATABASE_URL" -v ON_ERROR_STOP=1 <<PSQL
              DROP TABLE IF EXISTS _stage_approved;
              CREATE TEMP TABLE _stage_approved (
                barbora_uid   text,
                barbora_name  text,
                barbora_brand text,
                barbora_size  text,
                match_uid     text,
                match_name    text,
                match_brand   text,
                match_size    text,
                match_ean     text,
                store         text,
                similarity    numeric(5,4),
                size_diff_pct numeric(6,2),
                tier          text,
                is_best_match boolean
              );

              \\copy _stage_approved FROM '${f}' WITH CSV HEADER ENCODING 'UTF8';

              INSERT INTO approved_matches
              (barbora_uid, barbora_name, barbora_brand, barbora_size,
               match_uid, match_name, match_brand, match_size, match_ean,
               store, similarity, size_diff_pct, tier, is_best_match)
              SELECT
                NULLIF(BTRIM(barbora_uid), ''),
                barbora_name, barbora_brand, barbora_size,
                NULLIF(BTRIM(match_uid), ''),
                match_name, match_brand, match_size, match_ean,
                LOWER(NULLIF(BTRIM(store), '')),
                similarity, size_diff_pct, tier, is_best_match
              FROM _stage_approved
              WHERE NULLIF(BTRIM(barbora_uid),'') IS NOT NULL
                AND NULLIF(BTRIM(match_uid),'') IS NOT NULL
                AND NULLIF(BTRIM(store),'') IS NOT NULL
              ON CONFLICT (barbora_uid, store, match_uid) DO UPDATE SET
                barbora_name   = EXCLUDED.barbora_name,
                barbora_brand  = EXCLUDED.barbora_brand,
                barbora_size   = EXCLUDED.barbora_size,
                match_name     = EXCLUDED.match_name,
                match_brand    = EXCLUDED.match_brand,
                match_size     = EXCLUDED.match_size,
                match_ean      = EXCLUDED.match_ean,
                similarity     = EXCLUDED.similarity,
                size_diff_pct  = EXCLUDED.size_diff_pct,
                tier           = EXCLUDED.tier,
                is_best_match  = EXCLUDED.is_best_match,
                reviewed_at    = now();
              PSQL
            else
              echo "Skipping (not found): $f"
            fi
          }

          import_one "$CSV_DIR/approved_selver_matches.csv"
          import_one "$CSV_DIR/approved_rimi_matches.csv"
          import_one "$CSV_DIR/approved_prisma_matches.csv"

      - name: Sanity counts
        env:
          DATABASE_URL: ${{ steps.prep.outputs.url }}
        shell: bash
        run: |
          set -euo pipefail
          psql "$DATABASE_URL" -v ON_ERROR_STOP=1 <<'PSQL'
          \pset footer off
          SELECT 'approved_matches' AS table, COUNT(*) AS rows FROM approved_matches;
          -- test the view compiles
          SELECT COUNT(*) FROM approved_best_match_per_store;
          PSQL
