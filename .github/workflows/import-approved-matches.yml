name: Import approved matches (CSV to DB)

on:
  workflow_dispatch:
    inputs:
      run_set:
        description: "Which CSVs to import"
        type: choice
        options: [all, rimi, selver, prisma]
        default: all
      right_chain:
        description: "Target chain label for RIGHT side"
        required: true
        default: "Canonical"
      csv_has_chain_cols:
        description: "CSV already has left_chain,right_chain columns? (true/false)"
        required: true
        default: "false"

jobs:
  import:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include:
          - slug: rimi
            left_chain: Rimi
            csv_path: data/approved_rimi_matches.csv
          - slug: selver
            left_chain: Selver
            csv_path: data/approved_selver_matches.csv
          - slug: prisma
            left_chain: Prisma
            csv_path: data/approved_prisma_matches.csv

    steps:
      - name: Checkout
        if: ${{ github.event.inputs.run_set == 'all' || github.event.inputs.run_set == matrix.slug }}
        uses: actions/checkout@v4

      - name: Ensure CSV exists
        if: ${{ github.event.inputs.run_set == 'all' || github.event.inputs.run_set == matrix.slug }}
        shell: bash
        env:
          INPUT_CSV_PATH: ${{ matrix.csv_path }}
        run: |
          set -euo pipefail
          CSV_PATH="$GITHUB_WORKSPACE/$INPUT_CSV_PATH"
          echo "Checking CSV at: $CSV_PATH"
          test -f "$CSV_PATH" || { echo "CSV not found at: $CSV_PATH"; exit 1; }
          head -n 5 "$CSV_PATH" || true

      - name: Install psql client
        if: ${{ github.event.inputs.run_set == 'all' || github.event.inputs.run_set == matrix.slug }}
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y postgresql-client

      - name: Import CSV → approved_matches_active (idempotent upsert)
        if: ${{ github.event.inputs.run_set == 'all' || github.event.inputs.run_set == matrix.slug }}
        shell: bash
        env:
          # Preferred public URL (Railway external)
          DATABASE_URL_PUBLIC: ${{ secrets.DATABASE_URL_PUBLIC }}
          # Optional fallback full URL
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          # Component fallbacks
          PGHOST: ${{ secrets.PGHOST }}
          PGPORT: ${{ secrets.PGPORT }}
          PGUSER: ${{ secrets.PGUSER }}
          PGPASSWORD: ${{ secrets.PGPASSWORD }}
          PGDATABASE: ${{ secrets.PGDATABASE }}

          INPUT_CSV_PATH: ${{ matrix.csv_path }}
          INPUT_LEFT_CHAIN: ${{ matrix.left_chain }}
          INPUT_RIGHT_CHAIN: ${{ github.event.inputs.right_chain }}
          INPUT_CSV_HAS_CHAIN_COLS: ${{ github.event.inputs.csv_has_chain_cols }}
        run: |
          set -euo pipefail

          CSV_PATH="$GITHUB_WORKSPACE/$INPUT_CSV_PATH"
          LEFT_CHAIN="$INPUT_LEFT_CHAIN"
          RIGHT_CHAIN="$INPUT_RIGHT_CHAIN"
          CSV_HAS_CHAIN_COLS="$INPUT_CSV_HAS_CHAIN_COLS"

          # Build DB URL (prefer public, then regular, then components)
          DB_URL="${DATABASE_URL_PUBLIC:-}"
          if [[ -z "$DB_URL" ]]; then
            DB_URL="${DATABASE_URL:-}"
          fi
          if [[ -z "$DB_URL" ]]; then
            if [[ -n "${PGHOST:-}" && -n "${PGPORT:-}" && -n "${PGUSER:-}" && -n "${PGPASSWORD:-}" && -n "${PGDATABASE:-}" ]]; then
              DB_URL="postgresql://$PGUSER:$PGPASSWORD@$PGHOST:$PGPORT/$PGDATABASE"
            else
              echo "❌ Missing DB credentials. Set secrets.DATABASE_URL_PUBLIC or DATABASE_URL, or all of PGHOST/PGPORT/PGUSER/PGPASSWORD/PGDATABASE."
              exit 1
            fi
          fi
          # Ensure sslmode=require
          if [[ "$DB_URL" != *"sslmode="* ]]; then
            if [[ "$DB_URL" == *"?"* ]]; then DB_URL="${DB_URL}&sslmode=require"; else DB_URL="${DB_URL}?sslmode=require"; fi
          fi

          echo "== Connectivity check =="
          psql "$DB_URL" -Atc "select version();" >/dev/null

          SQL_FILE="/tmp/import_matches.sql"
          : > "$SQL_FILE"

          # 1) DDL + temp staging (echo lines to avoid YAML/heredoc issues)
          {
            echo '\set ON_ERROR_STOP on'
            echo 'BEGIN;'
            echo ''
            echo '-- Active table = one target per left item'
            echo 'CREATE TABLE IF NOT EXISTS approved_matches_active ('
            echo '  left_chain  text    NOT NULL,'
            echo '  left_key    text    NOT NULL,'
            echo '  right_chain text    NOT NULL,'
            echo '  right_key   text    NOT NULL,'
            echo '  note        text,'
            echo '  approved_by text,'
            echo '  approved_at timestamptz NOT NULL DEFAULT now(),'
            echo '  PRIMARY KEY (left_chain, left_key)'
            echo ');'
            echo ''
            echo 'DROP TABLE IF EXISTS approved_matches_import;'
            echo 'CREATE TEMP TABLE approved_matches_import ('
            echo '  left_chain  text,'
            echo '  left_key    text,'
            echo '  right_chain text,'
            echo '  right_key   text,'
            echo '  note        text,'
            echo '  approved_by text'
            echo ');'
          } >> "$SQL_FILE"

          # 2) COPY block
          if [[ "$CSV_HAS_CHAIN_COLS" == "true" ]]; then
            echo "\\copy approved_matches_import (left_chain,left_key,right_chain,right_key,note,approved_by) FROM '$CSV_PATH' CSV HEADER;" >> "$SQL_FILE"
          else
            echo "\\copy approved_matches_import (left_key,right_key,note,approved_by) FROM '$CSV_PATH' CSV HEADER;" >> "$SQL_FILE"
            echo "UPDATE approved_matches_import SET left_chain = :'LEFT_CHAIN', right_chain = :'RIGHT_CHAIN';" >> "$SQL_FILE"
          fi

          # 3) Upsert + commit
          {
            echo ''
            echo 'INSERT INTO approved_matches_active (left_chain,left_key,right_chain,right_key,note,approved_by)'
            echo 'SELECT left_chain,left_key,right_chain,right_key,note,approved_by'
            echo 'FROM approved_matches_import'
            echo 'WHERE left_key IS NOT NULL AND right_key IS NOT NULL'
            echo 'ON CONFLICT (left_chain,left_key) DO UPDATE'
            echo '  SET right_chain = EXCLUDED.right_chain,'
            echo '      right_key   = EXCLUDED.right_key,'
            echo '      note        = COALESCE(EXCLUDED.note, approved_matches_active.note),'
            echo '      approved_by = COALESCE(EXCLUDED.approved_by, approved_matches_active.approved_by),'
            echo '      approved_at = now();'
            echo ''
            echo 'COMMIT;'
            echo ''
            echo "SELECT :'LEFT_CHAIN'::text AS left_chain_running, COUNT(*) AS rows FROM approved_matches_active WHERE left_chain = :'LEFT_CHAIN';"
          } >> "$SQL_FILE"

          echo "=== Executing SQL for $LEFT_CHAIN ==="
          psql "$DB_URL" -v LEFT_CHAIN="$LEFT_CHAIN" -v RIGHT_CHAIN="$RIGHT_CHAIN" -f "$SQL_FILE"

      - name: Show sample rows
        if: ${{ github.event.inputs.run_set == 'all' || github.event.inputs.run_set == matrix.slug }}
        shell: bash
        env:
          DATABASE_URL_PUBLIC: ${{ secrets.DATABASE_URL_PUBLIC }}
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          PGHOST: ${{ secrets.PGHOST }}
          PGPORT: ${{ secrets.PGPORT }}
          PGUSER: ${{ secrets.PGUSER }}
          PGPASSWORD: ${{ secrets.PGPASSWORD }}
          PGDATABASE: ${{ secrets.PGDATABASE }}
        run: |
          set -euo pipefail
          DB_URL="${DATABASE_URL_PUBLIC:-${DATABASE_URL:-}}"
          if [[ -z "$DB_URL" ]]; then
            DB_URL="postgresql://$PGUSER:$PGPASSWORD@$PGHOST:$PGPORT/$PGDATABASE"
          fi
          if [[ "$DB_URL" != *"sslmode="* ]]; then
            if [[ "$DB_URL" == *"?"* ]]; then DB_URL="${DB_URL}&sslmode=require"; else DB_URL="${DB_URL}?sslmode=require"; fi
          fi
          psql "$DB_URL" -c "TABLE approved_matches_active LIMIT 15;"
