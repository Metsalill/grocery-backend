name: "Selver → Seed stores (online + physical)"

on:
  workflow_dispatch:
    inputs:
      geocode:
        description: "Geocode with Nominatim (0/1). If 1, adds lat/lon (slower)."
        required: false
        default: "0"
      chain:
        description: "Retail chain label"
        required: false
        default: "Selver"
      online_name:
        description: "Name of online store"
        required: false
        default: "e-Selver"
      dry_run:
        description: "Dry run (0/1) — parse only, no DB writes"
        required: false
        default: "0"

concurrency:
  group: seed-selver-stores
  cancel-in-progress: true

jobs:
  seed:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    env:
      DATABASE_URL: ${{ secrets.RW_DATABASE_URL }}
      GEOCODE: ${{ github.event.inputs.geocode }}
      DRY_RUN: ${{ github.event.inputs.dry_run }}
      SELVER_CHAIN: ${{ github.event.inputs.chain }}
      ONLINE_NAME: ${{ github.event.inputs.online_name }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install deps (Playwright + DB + HTTP)
        run: |
          python -m pip install --upgrade pip
          pip install playwright psycopg2-binary aiohttp
          python -m playwright install --with-deps chromium

      - name: Create Playwright seeder script (inline)
        shell: bash
        run: |
          cat > selver_seed_stores_pw.py << 'PY'
          import os, re, time, sys, asyncio, aiohttp
          import psycopg2
          from playwright.sync_api import sync_playwright

          DB_URL = os.environ.get("DATABASE_URL")
          if not DB_URL:
            print("::error::DATABASE_URL secret not set"); sys.exit(1)

          GEOCODE = os.environ.get("GEOCODE","0") == "1"
          DRY_RUN = os.environ.get("DRY_RUN","0") == "1"
          CHAIN   = os.environ.get("SELVER_CHAIN","Selver")
          ONLINE  = os.environ.get("ONLINE_NAME","e-Selver")

          def render_and_extract():
            names = set()
            with sync_playwright() as pw:
              b = pw.chromium.launch(headless=True)
              p = b.new_page()
              p.goto("https://www.selver.ee/kauplused", wait_until="load", timeout=60000)
              # Try to accept cookies if banner appears (best-effort)
              for txt in ["Nõustun", "Nõustu", "Accept", "Allow all"]:
                try:
                  p.get_by_role("button", name=re.compile(txt, re.I)).click(timeout=1500)
                  break
                except Exception:
                  pass

              # Give JS a moment to render
              p.wait_for_timeout(1500)

              # Collect candidate texts from anchors/headings/list items
              texts = []
              for sel in ["a", "h1", "h2", "h3", "li", "span", "div"]:
                try:
                  texts += p.locator(sel).all_inner_texts()
                except Exception:
                  pass

              for t in texts:
                t = re.sub(r"\s+", " ", t).strip()
                # Match names that end with Selver (optionally ABC) or contain Delice
                if re.search(r"(Selver(?:\s+ABC)?$)|(^Delice\b)", t, re.I):
                  # Filter overly generic lines
                  if len(t) >= 6 and "e-Selver" not in t:
                    names.add(t)

              # Also try links that navigate to store subpages
              try:
                hrefs = p.locator("a[href*='/kauplused']").evaluate_all("els => els.map(e => e.textContent)")
                for t in hrefs:
                  if t:
                    t = re.sub(r"\s+", " ", t).strip()
                    if re.search(r"(Selver(?:\s+ABC)?$)|(^Delice\b)", t, re.I) and "e-Selver" not in t:
                      names.add(t)
              except Exception:
                pass

              b.close()
            return sorted(names)

          async def geocode_one(session, name):
            url = "https://nominatim.openstreetmap.org/search"
            params = {"q": f"{name}, Estonia", "format": "json", "limit": 1}
            headers = {"User-Agent": "grocery-backend/seed-selver-stores (+gha)"}
            try:
              async with session.get(url, params=params, headers=headers, timeout=30) as r:
                r.raise_for_status()
                data = await r.json()
                if not data: return None, None
                return float(data[0]["lat"]), float(data[0]["lon"])
            except Exception:
              return None, None

          async def geocode_all(names):
            out = {}
            if not GEOCODE:
              return {n: (None, None) for n in names}
            async with aiohttp.ClientSession() as session:
              for n in names:
                lat, lon = await geocode_one(session, n)
                out[n] = (lat, lon)
                time.sleep(1)  # fair use
            return out

          def upsert(names, coords):
            if DRY_RUN:
              print(f"Dry run: {len(names)} stores parsed")
              for n in names: print(" -", n)
              return

            conn = psycopg2.connect(DB_URL)
            conn.autocommit = True
            cur = conn.cursor()

            # Ensure columns exist (idempotent)
            cur.execute("""
            DO $$
            BEGIN
              IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='stores' AND column_name='chain') THEN
                ALTER TABLE stores ADD COLUMN chain TEXT;
              END IF;
              IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='stores' AND column_name='is_online') THEN
                ALTER TABLE stores ADD COLUMN is_online BOOLEAN NOT NULL DEFAULT FALSE;
              END IF;
              IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='stores' AND column_name='lat') THEN
                ALTER TABLE stores ADD COLUMN lat DOUBLE PRECISION;
              END IF;
              IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='stores' AND column_name='lon') THEN
                ALTER TABLE stores ADD COLUMN lon DOUBLE PRECISION;
              END IF;
            END $$;""")

            # Upsert online store
            cur.execute("""
              INSERT INTO stores (name, chain, is_online)
              VALUES (%s, %s, TRUE)
              ON CONFLICT DO NOTHING;
            """, (ONLINE, CHAIN))

            # Upsert physical stores
            sql = """
              INSERT INTO stores (name, chain, is_online, lat, lon)
              VALUES (%s, %s, FALSE, %s, %s)
              ON CONFLICT DO NOTHING;
            """
            for n in names:
              lat, lon = coords.get(n, (None, None))
              cur.execute(sql, (n, CHAIN, lat, lon))

            cur.close(); conn.close()
            print(f"Upsert complete: {len(names)} physical stores")

          if __name__ == "__main__":
            names = render_and_extract()
            print(f"Found {len(names)} Selver/Delice physical names.")
            if len(names) == 0:
              print("::warning::No stores parsed; page likely blocked or structure changed.")
            coords = asyncio.run(geocode_all(names))
            upsert(names, coords)
          PY

      - name: Run seeder
        env:
          PYTHONUNBUFFERED: "1"
        run: |
          echo "GEOCODE=${GEOCODE} DRY_RUN=${DRY_RUN} CHAIN=${SELVER_CHAIN} ONLINE_NAME=${ONLINE_NAME}"
          python selver_seed_stores_pw.py
