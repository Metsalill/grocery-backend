name: Coop Vandra EAN backfill (from Haapsalu matches)

on:
  workflow_dispatch:
    inputs:
      wipe_before:
        description: "Wipe existing Vandra EANs before backfill? (yes/no)"
        required: true
        default: "no"
      strong_csv:
        description: "Path to coop_match_strong.csv (in repo)"
        required: true
        default: "data/coop_match_strong.csv"
      medium_csv:
        description: "Path to coop_match_medium.csv (in repo)"
        required: true
        default: "data/coop_match_medium.csv"
      weak_csv:
        description: "Path to coop_match_weak.csv (in repo)"
        required: true
        default: "data/coop_match_weak.csv"

jobs:
  backfill:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install tools
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client python3

      - name: Verify CSVs exist
        shell: bash
        run: |
          for f in "${{ inputs.strong_csv }}" "${{ inputs.medium_csv }}" "${{ inputs.weak_csv }}"; do
            [ -f "$f" ] || { echo "::error::Missing file: $f"; exit 1; }
            echo "Found $f"; head -n 1 "$f" || true
          done

      - name: Build map CSV (priority strong > medium > weak)
        id: buildmap
        shell: bash
        env:
          STRONG: "${{ inputs.strong_csv }}"
          MEDIUM: "${{ inputs.medium_csv }}"
          WEAK: "${{ inputs.weak_csv }}"
        run: |
          python3 - <<'PY'
          import csv, os
          from pathlib import Path

          strong = Path(os.environ["STRONG"])
          medium = Path(os.environ["MEDIUM"])
          weak = Path(os.environ["WEAK"])
          inputs = [("strong", strong), ("medium", medium), ("weak", weak)]
          priority = {"strong": 3, "medium": 2, "weak": 1}

          def clean_ean(s):
            if s is None: return ""
            s = str(s).strip()
            if s.endswith(".0"): s = s[:-2]
            return s

          out_map = {}   # vandra_ext_id -> (prio, ean, source)
          conflicts = [] # [vandra_ext_id, existing_ean, new_ean, kept_from, skipped_from]

          for label, fp in inputs:
            with fp.open("r", encoding="utf-8") as f:
              r = csv.DictReader(f)
              headers = [h.strip().lower() for h in r.fieldnames]
              try:
                ve_idx = headers.index("vandra_ext_id")
                ean_idx = headers.index("ean_to_copy_to_vandra")
              except ValueError:
                raise SystemExit(f"Required columns not found in {fp}. Headers: {r.fieldnames}")
              for row in r:
                ext = (row[r.fieldnames[ve_idx]] or "").strip()
                ean = clean_ean(row[r.fieldnames[ean_idx]])
                if not ext or not ean:
                  continue
                if ext not in out_map:
                  out_map[ext] = (priority[label], ean, label)
                else:
                  cur_p, cur_ean, cur_src = out_map[ext]
                  new_p = priority[label]
                  if new_p > cur_p:
                    if cur_ean != ean:
                      conflicts.append([ext, cur_ean, ean, label, cur_src])
                    out_map[ext] = (new_p, ean, label)
                  elif new_p == cur_p and cur_ean != ean:
                    conflicts.append([ext, cur_ean, ean, cur_src, label])

          map_path = Path("/tmp/vandra_map.csv")
          with map_path.open("w", newline="", encoding="utf-8") as f:
            w = csv.writer(f)
            w.writerow(["vandra_ext_id","ean"])
            for ext, (_, ean, _) in out_map.items():
              w.writerow([ext, ean])

          conf_path = Path("/tmp/vandra_conflicts.csv")
          with conf_path.open("w", newline="", encoding="utf-8") as f:
            w = csv.writer(f)
            w.writerow(["vandra_ext_id","existing_ean","new_ean","kept_from","skipped_from"])
            w.writerows(conflicts)

          # Expose outputs
          with open(os.environ["GITHUB_OUTPUT"], "a") as gh:
            gh.write(f"map={map_path}\n")
            gh.write(f"conflicts={conf_path}\n")
          PY

      - name: Before counts
        shell: bash
        env:
          DATABASE_URL: "${{ secrets.DATABASE_URL_PUBLIC }}"
        run: |
          cat > before.sql <<'SQL'
          WITH latest AS (
            SELECT DISTINCT ON (store_host, ext_id) *
            FROM staging_coop_products
            WHERE store_host IN ('coophaapsalu.ee','vandra.ecoop.ee')
            ORDER BY store_host, ext_id, scraped_at DESC
          )
          SELECT
            store_host,
            COUNT(DISTINCT ext_id) AS distinct_products,
            COUNT(DISTINCT NULLIF(COALESCE(ean_norm, ean_raw), '')) AS unique_eans
          FROM latest
          GROUP BY store_host
          ORDER BY store_host;
          SQL
          psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -f before.sql

      - name: Wipe existing Vandra EANs (optional)
        if: ${{ inputs.wipe_before == 'yes' }}
        shell: bash
        env:
          DATABASE_URL: "${{ secrets.DATABASE_URL_PUBLIC }}"
        run: |
          cat > wipe.sql <<'SQL'
          BEGIN;
          UPDATE staging_coop_products
          SET ean_norm = NULL, ean_raw = NULL
          WHERE store_host = 'vandra.ecoop.ee'
            AND (COALESCE(ean_norm,'') <> '' OR COALESCE(ean_raw,'') <> '');
          COMMIT;
          SQL
          psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -f wipe.sql

      - name: Backfill from matches (only Vandra)
        shell: bash
        env:
          DATABASE_URL: "${{ secrets.DATABASE_URL_PUBLIC }}"
        run: |
          echo "Using map: ${{ steps.buildmap.outputs.map }}"
          test -f "${{ steps.buildmap.outputs.map }}" || { echo "::error::map file missing"; exit 1; }

          cat > backfill.sql <<'SQL'
          BEGIN;

          DROP TABLE IF EXISTS tmp_vandra_ean_map;
          CREATE TEMP TABLE tmp_vandra_ean_map (
            vandra_ext_id text,
            ean text
          );

          \copy tmp_vandra_ean_map (vandra_ext_id, ean) FROM '${{ steps.buildmap.outputs.map }}' WITH (FORMAT csv, HEADER true)

          WITH upd AS (
            UPDATE staging_coop_products s
            SET
              ean_norm = COALESCE(NULLIF(s.ean_norm,''), m.ean),
              ean_raw  = COALESCE(NULLIF(s.ean_raw,''),  m.ean)
            FROM tmp_vandra_ean_map m
            WHERE s.store_host = 'vandra.ecoop.ee'
              AND s.ext_id = m.vandra_ext_id
              AND (NULLIF(s.ean_norm,'') IS NULL OR NULLIF(s.ean_raw,'') IS NULL)
            RETURNING s.ext_id
          )
          SELECT COUNT(*) AS vandra_rows_updated FROM upd;

          COMMIT;
          SQL

          psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -f backfill.sql

      - name: After counts
        shell: bash
        env:
          DATABASE_URL: "${{ secrets.DATABASE_URL_PUBLIC }}"
        run: |
          psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -f before.sql

      - name: Upload conflict report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: vandra-conflicts
          path: "${{ steps.buildmap.outputs.conflicts }}"
