name: Import Barbora Strong Matches (legacy schema)

on:
  workflow_dispatch:

jobs:
  import-strong-legacy:
    runs-on: ubuntu-latest
    env:
      DATABASE_URL: ${{ secrets.DATABASE_URL_PUBLIC }}
    steps:
      - uses: actions/checkout@v4

      - name: Install PostgreSQL client
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client

      - name: Prepare staging (matches CSV headers)
        run: |
          psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -X <<'SQL'
          CREATE TABLE IF NOT EXISTS staging_barbora_matches (
            left_chain        text,
            left_ext_id       text,
            left_name         text,
            left_brand        text,
            left_size_text    text,
            right_chain       text,
            right_ext_id      text,
            right_name        text,
            right_brand       text,
            right_size_text   text,
            match_reason      text,
            match_score       numeric
          );
          SQL

      - name: Load only *strong* CSVs into staging
        run: |
          set -euo pipefail
          shopt -s nullglob
          files=(data/matches/matches_Barbora_to_*_strong.csv)
          if [ ${#files[@]} -eq 0 ]; then
            echo "No *strong* CSVs found under data/matches/"
            exit 1
          fi
          psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -X -c "TRUNCATE staging_barbora_matches;"
          for f in "${files[@]}"; do
            echo "Loading $f"
            psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -X \
              -c "\copy staging_barbora_matches FROM '${f}' WITH (FORMAT CSV, HEADER, ENCODING 'UTF8')"
          done
          # keep only strong (defensive)
          psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -X \
            -c "DELETE FROM staging_barbora_matches WHERE match_reason IS DISTINCT FROM 'strong';"

      - name: Upsert into approved_matches_active (legacy columns only)
        run: |
          psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -X <<'SQL'
          -- unique index for upsert (safe if a PK already covers it)
          DO $$
          BEGIN
            IF NOT EXISTS (
              SELECT 1 FROM pg_indexes
              WHERE tablename='approved_matches_active'
                AND indexname='ux_ama_left_ext_right'
            ) THEN
              BEGIN
                CREATE UNIQUE INDEX ux_ama_left_ext_right
                ON approved_matches_active (left_chain, left_ext_id, right_chain);
              EXCEPTION WHEN duplicate_table THEN NULL;
              END;
            END IF;
          END$$;

          INSERT INTO approved_matches_active (
            left_chain, left_ext_id, right_chain, right_ext_id,
            score, tier,
            left_name, left_brand, left_size_text,
            right_name, right_brand, right_size_text
          )
          SELECT
            COALESCE(NULLIF(left_chain,''), 'Barbora') AS left_chain,
            left_ext_id,
            right_chain,
            NULLIF(right_ext_id,'')                    AS right_ext_id,
            match_score                                 AS score,
            match_reason                                AS tier,
            left_name, left_brand, left_size_text,
            right_name, right_brand, right_size_text
          FROM staging_barbora_matches
          WHERE match_reason = 'strong'
          ON CONFLICT (left_chain, left_ext_id, right_chain)
          DO UPDATE SET
            right_ext_id    = EXCLUDED.right_ext_id,
            score           = EXCLUDED.score,
            tier            = EXCLUDED.tier,
            left_name       = EXCLUDED.left_name,
            left_brand      = EXCLUDED.left_brand,
            left_size_text  = EXCLUDED.left_size_text,
            right_name      = EXCLUDED.right_name,
            right_brand     = EXCLUDED.right_brand,
            right_size_text = EXCLUDED.right_size_text;
          SQL

      - name: Verify imported counts
        run: |
          psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -X <<'SQL'
          SELECT right_chain AS chain,
                 COUNT(*)    AS strong_rows,
                 ROUND(AVG(score)::numeric, 4) AS avg_score
          FROM approved_matches_active
          WHERE left_chain = 'Barbora' AND tier = 'strong'
          GROUP BY right_chain
          ORDER BY right_chain;
          SQL
