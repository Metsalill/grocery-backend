name: Export all chains (matching dataset, ONLINE ONLY)

on:
  workflow_dispatch:

jobs:
  export:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        chain: [Selver, Prisma, Rimi, Barbora] # Barbora = Maxima online

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install PostgreSQL client
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client

      - name: Export ${{ matrix.chain }} products CSV (ONLINE ONLY)
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p out

          # DB connection
          export DATABASE_URL="${{ secrets.DATABASE_URL_PUBLIC }}"

          # Ensure extensions exist (safe if already present)
          psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -X -c "CREATE EXTENSION IF NOT EXISTS unaccent;"

          # Write SQL to a file to avoid YAML/bash escaping issues
          cat > export.sql <<'SQL'
          COPY (
            WITH online_stores AS (
              SELECT
                s.*,
                (
                  COALESCE(s.is_online, false)
                  OR COALESCE(lower(s.channel) = 'online', false)
                  OR COALESCE(lower(s.type) = 'online', false)
                  OR COALESCE(s.tags ILIKE '%online%', false)
                  OR COALESCE(s.name ILIKE '%e-pood%' OR s.name ILIKE '%e-shop%', false)
                  OR COALESCE(s.url ~* '(barbora\.ee|rimi\.ee|selver\.ee|prismamarket\.ee|prisma\.ee)', false)
                ) AS is_eshop
              FROM stores s
            ),

            base AS (
              SELECT
                -- Final chain label: Barbora (even if store.chain says Maxima)
                CASE WHEN lower(s.chain) LIKE 'maxima%' THEN 'Barbora' ELSE s.chain END AS chain,
                s.name        AS store_name,
                s.id          AS store_id,
                p.id          AS product_id,
                p.name        AS product,
                p.brand       AS brand_canonical,
                COALESCE(NULLIF(p.amount, ''), p.size_text) AS size_text,
                p.ean,
                pr.price,
                pr.collected_at,
                -- normalized chain key for joins
                CASE
                  WHEN lower(s.chain) LIKE 'maxima%' THEN 'barbora'
                  WHEN lower(s.chain) LIKE 'selver%'  THEN 'selver'
                  WHEN lower(s.chain) LIKE 'prisma%'  THEN 'prisma'
                  WHEN lower(s.chain) LIKE 'rimi%'    THEN 'rimi'
                  ELSE lower(s.chain)
                END           AS chain_norm,
                -- normalize product name (ASCII, spaces)
                regexp_replace(unaccent(lower(p.name)), '[^a-z0-9]+', ' ', 'g') AS name_norm
              FROM prices pr
              JOIN products p ON p.id = pr.product_id
              JOIN online_stores s ON s.id = pr.store_id AND s.is_eshop = true
              WHERE
                -- Limit to the requested chain in the matrix, mapping Maxima → Barbora
                (
                  ( :'chain' = 'Barbora' AND lower(s.chain) LIKE 'maxima%' ) OR
                  ( :'chain' <> 'Barbora' AND s.chain ILIKE :'chain' || '%' )
                )
            ),

            epm AS (  -- ext ids for Selver/Prisma/Rimi (and any future Barbora entries)
              SELECT
                CASE
                  WHEN lower(source) IN ('barbora','maxima') THEN 'barbora'
                  WHEN lower(source) = 'selver' THEN 'selver'
                  WHEN lower(source) = 'prisma' THEN 'prisma'
                  WHEN lower(source) = 'rimi'   THEN 'rimi'
                  ELSE lower(source)
                END AS chain_norm,
                product_id,
                ext_id
              FROM ext_product_map
            ),

            -- Barbora candidates: normalize by NAME and bring Barbora brand + ext_id
            bc AS (
              SELECT
                regexp_replace(unaccent(lower(name)), '[^a-z0-9]+', ' ', 'g') AS name_norm,
                MIN(ext_id)                             AS ext_id,
                MAX(NULLIF(trim(brand), ''))            AS brand_barbora
              FROM barbora_candidates
              GROUP BY 1
            )

            SELECT
              b.chain,
              b.store_name,
              b.store_id,
              b.product_id,
              b.product,
              -- Prefer Barbora’s brand when chain is Barbora; otherwise canonical
              CASE
                WHEN b.chain_norm = 'barbora' THEN COALESCE(bc.brand_barbora, b.brand_canonical)
                ELSE b.brand_canonical
              END AS brand,
              b.size_text,
              b.ean,
              b.name_norm,
              -- Barbora gets ext_id from candidates by name; others from ext map
              CASE
                WHEN b.chain_norm = 'barbora' THEN bc.ext_id
                ELSE e.ext_id
              END AS ext_id,
              b.price,
              b.collected_at
            FROM base b
            LEFT JOIN epm e
              ON e.chain_norm = b.chain_norm AND e.product_id = b.product_id
            LEFT JOIN bc
              ON b.chain_norm = 'barbora' AND bc.name_norm = b.name_norm
          ) TO STDOUT WITH (FORMAT CSV, HEADER, ENCODING 'UTF8');
          SQL

          # Run export for the matrix chain
          psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -X -v chain="${{ matrix.chain }}" -f export.sql \
            > "out/${{ matrix.chain }}_products.csv"

      - name: Upload ${{ matrix.chain }} CSV
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.chain }}-products
          path: out/${{ matrix.chain }}_products.csv
