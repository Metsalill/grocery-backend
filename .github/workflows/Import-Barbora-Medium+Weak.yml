name: Import Barbora Medium+Weak Matches (links + best active)

on:
  workflow_dispatch:

jobs:
  import:
    runs-on: ubuntu-latest
    env:
      DATABASE_URL: ${{ secrets.DATABASE_URL_PUBLIC }}

    steps:
      - name: Set up job
        run: echo "Starting medium+weak import…"

      - uses: actions/checkout@v4

      - name: Install PostgreSQL client
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client

      - name: Prepare staging (CSV shape)
        run: |
          psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -X <<'SQL'
          CREATE TABLE IF NOT EXISTS staging_barbora_matches (
            left_chain      text,
            left_ext_id     text,
            left_name       text,
            left_brand      text,
            left_size_text  text,
            right_chain     text,
            right_ext_id    text,
            right_name      text,
            right_brand     text,
            right_size_text text,
            match_reason    text,
            match_score     numeric
          );
          SQL

      - name: Load medium + weak CSVs
        run: |
          set -euo pipefail
          shopt -s nullglob
          files=( \
            data/matches/matches_Barbora_to_*_medium*.csv \
            data/matches/matches_Barbora_to_*_weak*.csv \
          )
          if [ ${#files[@]} -eq 0 ]; then
            echo "❌ No medium/weak CSVs found under data/matches/"
            exit 1
          fi
          psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -X -c "TRUNCATE staging_barbora_matches;"
          for f in "${files[@]}"; do
            echo "➡️ Loading $f"
            psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -X \
              -c "\copy staging_barbora_matches FROM '${f}' WITH (FORMAT CSV, HEADER, ENCODING 'UTF8')"
          done
          psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -X \
            -c "DELETE FROM staging_barbora_matches WHERE match_reason NOT IN ('medium','weak');"

      - name: Insert medium+weak into approved_product_links (many-to-many, keep strong)
        run: |
          psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -X <<'SQL'
          -- Many-to-many link table (idempotent)
          CREATE TABLE IF NOT EXISTS approved_product_links (
            left_chain       text,
            left_product_id  bigint,
            right_chain      text,
            right_product_id bigint,
            score            numeric,
            tier             text,
            PRIMARY KEY (left_chain, left_product_id, right_chain)
          );

          WITH ranked AS (
            SELECT
              COALESCE(NULLIF(left_ext_id,''), '') AS left_ext_id,
              right_chain,
              NULLIF(right_ext_id,'')             AS right_ext_id,
              match_score, match_reason,
              ROW_NUMBER() OVER (
                PARTITION BY left_ext_id, right_chain
                ORDER BY match_score DESC NULLS LAST
              ) AS rn
            FROM staging_barbora_matches
            WHERE match_reason IN ('medium','weak')
          ),
          dedup AS (
            SELECT * FROM ranked WHERE rn = 1
          ),

          -- LEFT (Barbora) via product_aliases (Barbora doesn’t have ext_product_map)
          lmap AS (
            SELECT d.left_ext_id, ba.product_id AS left_product_id
            FROM dedup d
            JOIN product_aliases ba
              ON lower(ba.source) = 'barbora'
             AND lower(ba.alias)  = d.left_ext_id
          ),

          -- RIGHT via ext_product_map, with fallback to product_aliases
          rmap_raw AS (
            SELECT
              d.right_chain,
              d.right_ext_id,
              ep.product_id        AS ep_pid,
              ba.product_id        AS ba_pid
            FROM dedup d
            LEFT JOIN ext_product_map ep
              ON ep.ext_id = d.right_ext_id
             AND (
               (lower(d.right_chain) LIKE 'rimi%'   AND lower(ep.source) = 'rimi')   OR
               (lower(d.right_chain) LIKE 'prisma%' AND lower(ep.source) = 'prisma') OR
               (lower(d.right_chain) LIKE 'selver%' AND lower(ep.source) = 'selver')
             )
            LEFT JOIN product_aliases ba
              ON lower(ba.alias) = d.right_ext_id
             AND (
               (lower(d.right_chain) LIKE 'rimi%'   AND lower(ba.source) = 'rimi')   OR
               (lower(d.right_chain) LIKE 'prisma%' AND lower(ba.source) = 'prisma') OR
               (lower(d.right_chain) LIKE 'selver%' AND lower(ba.source) = 'selver')
             )
          ),
          rmap AS (
            SELECT right_chain, right_ext_id,
                   COALESCE(ep_pid, ba_pid) AS right_product_id
            FROM rmap_raw
          ),

          resolved AS (
            SELECT
              'Barbora' AS left_chain,
              l.left_product_id,
              r.right_chain,
              r.right_product_id,
              d.match_score AS score,
              d.match_reason AS tier
            FROM dedup d
            JOIN lmap l ON l.left_ext_id   = d.left_ext_id
            JOIN rmap r ON r.right_ext_id  = d.right_ext_id
            WHERE l.left_product_id  IS NOT NULL
              AND r.right_product_id IS NOT NULL
          )

          INSERT INTO approved_product_links
          (left_chain, left_product_id, right_chain, right_product_id, score, tier)
          SELECT * FROM resolved
          ON CONFLICT (left_chain, left_product_id, right_chain)
          DO UPDATE
          SET right_product_id = EXCLUDED.right_product_id,
              score            = EXCLUDED.score,
              tier             = EXCLUDED.tier
          WHERE approved_product_links.tier IS DISTINCT FROM 'strong';
          SQL

      - name: Upsert BEST medium/weak per Barbora into approved_matches_active (do not override strong)
        run: |
          psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -X <<'SQL'
          CREATE UNIQUE INDEX IF NOT EXISTS ux_ama_source_target
          ON approved_matches_active (source_chain, source_ext_id, target_chain);

          WITH ranked AS (
            SELECT
              NULLIF(left_ext_id,'')  AS left_ext_id,
              NULLIF(right_ext_id,'') AS right_ext_id,
              right_chain,
              match_score, match_reason,
              left_name, left_brand, left_size_text,
              right_name, right_brand, right_size_text,
              ROW_NUMBER() OVER (
                PARTITION BY NULLIF(left_ext_id,'')
                ORDER BY match_score DESC NULLS LAST
              ) AS rn
            FROM staging_barbora_matches
            WHERE match_reason IN ('medium','weak')
              AND NULLIF(left_ext_id,'')  IS NOT NULL
              AND NULLIF(right_ext_id,'') IS NOT NULL
          ),
          best AS (
            SELECT * FROM ranked WHERE rn = 1
          )
          INSERT INTO approved_matches_active (
            source_chain, source_ext_id, target_chain, target_ext_id,
            left_chain,  left_key,     right_chain,  right_key,
            score, tier,
            left_name, left_brand, left_size_text,
            right_name, right_brand, right_size_text
          )
          SELECT
            'Barbora', left_ext_id, right_chain, right_ext_id,
            'Barbora', left_ext_id, right_chain, right_ext_id,
            match_score, match_reason,
            left_name, left_brand, left_size_text,
            right_name, right_brand, right_size_text
          FROM best
          ON CONFLICT ON CONSTRAINT approved_matches_active_pkey
          DO UPDATE SET
            source_chain    = EXCLUDED.source_chain,
            source_ext_id   = EXCLUDED.source_ext_id,
            target_chain    = EXCLUDED.target_chain,
            target_ext_id   = EXCLUDED.target_ext_id,
            right_chain     = EXCLUDED.right_chain,
            right_key       = EXCLUDED.right_key,
            score           = EXCLUDED.score,
            tier            = EXCLUDED.tier,
            left_name       = EXCLUDED.left_name,
            left_brand      = EXCLUDED.left_brand,
            left_size_text  = EXCLUDED.left_size_text,
            right_name      = EXCLUDED.right_name,
            right_brand     = EXCLUDED.right_brand,
            right_size_text = EXCLUDED.right_size_text
          WHERE approved_matches_active.tier IS DISTINCT FROM 'strong';
          SQL

      - name: Verify results
        run: |
          psql "$DATABASE_URL" -v ON_ERROR_STOP=1 -X <<'SQL'
          \echo '→ approved_product_links (Barbora -> others)'
          SELECT right_chain, COUNT(*) AS links
          FROM approved_product_links
          WHERE left_chain = 'Barbora'
          GROUP BY right_chain
          ORDER BY right_chain;

          \echo '→ approved_matches_active (Barbora, by tier & chain)'
          SELECT target_chain AS chain,
                 tier,
                 COUNT(*) AS rows,
                 ROUND(AVG(score)::numeric, 3) AS avg_score
          FROM approved_matches_active
          WHERE source_chain = 'Barbora'
          GROUP BY target_chain, tier
          ORDER BY chain, tier;
          SQL

      - name: Complete job
        run: echo "✅ Medium+weak import finished."
