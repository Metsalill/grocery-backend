name: Sync Rimi physical stores

on:
  workflow_dispatch: {}

jobs:
  sync:
    runs-on: ubuntu-latest
    env:
      DATABASE_URL: ${{ secrets.DATABASE_URL_PUBLIC }}

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install Playwright
        run: |
          npm i -D playwright@1
          npx playwright install --with-deps chromium

      - name: Scrape Rimi stores -> CSV
        run: |
          mkdir -p scripts out
          cat > scripts/sync_rimi_stores.mjs <<'JS'
          import { chromium } from 'playwright';

          // Helper: pull lat/lon from a Google Maps "Juhised" link
          function coordsFromHref(href) {
            try {
              const u = new URL(href);
              // patterns: "@LAT,LON", or "query=LAT,LON"
              const at = href.match(/@(-?\d+(\.\d+)?),\s*(-?\d+(\.\d+)?)/);
              if (at) return { lat: +at[1], lon: +at[3] };
              const q = u.searchParams.get('query');
              if (q) {
                const m = q.match(/(-?\d+(\.\d+)?),\s*(-?\d+(\.\d+)?)/);
                if (m) return { lat: +m[1], lon: +m[3] };
              }
            } catch {}
            return { lat: null, lon: null };
          }

          // Scrape list page for detail links, then visit each detail page
          const browser = await chromium.launch();
          const page = await browser.newPage();
          await page.goto('https://www.rimi.ee/kauplused', { waitUntil: 'domcontentloaded' });

          // Accept cookies if shown (best-effort)
          try {
            const btn = await page.locator('button:has-text("Nõustun"), button:has-text("Accept")').first();
            if (await btn.isVisible()) await btn.click();
          } catch {}

          // Lazy-load list (scroll until it stops growing)
          let lastCount = -1;
          for (let i = 0; i < 20; i++) {
            await page.mouse.wheel(0, 20000);
            await page.waitForTimeout(800);
            const linksNow = await page.locator('a[href^="/kauplus/"]').count();
            if (linksNow === lastCount) break;
            lastCount = linksNow;
          }

          // Collect unique detail links
          const detailLinks = Array.from(new Set(
            await page.locator('a[href^="/kauplus/"]').evaluateAll(els => els.map(e => e.href))
          ));

          const rows = [];
          for (const href of detailLinks) {
            try {
              const p = await browser.newPage();
              await p.goto(href, { waitUntil: 'domcontentloaded' });

              const name = (await p.locator('h1').first().textContent() || '').trim();

              // Address block: try common selectors first, then fallback to visible text around “Aadress”
              let address = '';
              for (const sel of [
                '[itemprop="streetAddress"]', 'address', '.store-card__address', 'li:has-text("Aadress")'
              ]) {
                if (!address || address.length < 5) {
                  const t = (await p.locator(sel).first().textContent() || '').trim();
                  if (t && t.length > 5) address = t;
                }
              }
              if (!address) {
                // Very coarse fallback: first visible block near the map / directions
                address = (await p.locator('text=Aadress').locator('xpath=..').first().textContent() || '').trim();
              }

              // Directions link (usually Google Maps)
              const juhisedHref = await p.locator('a:has-text("Juhised"), a:has-text("Directions")').first().getAttribute('href');
              const { lat, lon } = juhisedHref ? coordsFromHref(juhisedHref) : { lat: null, lon: null };

              // classify type from name (“mini/super/hyper”)
              const lower = name.toLowerCase();
              let type = null;
              if (lower.includes('mini'))  type = 'Mini';
              if (lower.includes('super')) type = 'Super';
              if (lower.includes('hyper')) type = 'Hyper';

              rows.push({
                name, address, lat, lon, type, source_url: href
              });
              await p.close();
            } catch (e) {
              // ignore single-store failures; continue
            }
          }

          // Write CSV
          const fs = await import('node:fs/promises');
          const header = 'name,address,lat,lon,type,source_url\n';
          const lines = rows.map(r =>
            [r.name, r.address, r.lat ?? '', r.lon ?? '', r.type ?? '', r.source_url]
              .map(s => `"${String(s ?? '').replace(/"/g,'""')}"`).join(',')
          );
          await fs.writeFile('out/rimi_stores.csv', header + lines.join('\n'), 'utf8');
          await browser.close();
          console.log(`Wrote ${rows.length} rows to out/rimi_stores.csv`);
          JS
          node scripts/sync_rimi_stores.mjs

      - name: Upsert into Postgres (stores + mapping/view)
        run: |
          set -euo pipefail
          psql "$DATABASE_URL" -v ON_ERROR_STOP=1 <<'SQL'
          -- Make sure stores has the columns we need
          ALTER TABLE stores
            ADD COLUMN IF NOT EXISTS address text,
            ADD COLUMN IF NOT EXISTS lat numeric,
            ADD COLUMN IF NOT EXISTS lon numeric;

          -- Create a staging table
          DROP TABLE IF EXISTS staging_rimi_stores;
          CREATE TABLE staging_rimi_stores(
            name text,
            address text,
            lat numeric,
            lon numeric,
            type text,
            source_url text
          );

          \copy staging_rimi_stores(name,address,lat,lon,type,source_url) FROM 'out/rimi_stores.csv' WITH CSV HEADER;

          -- Ensure our online store row exists & keep id=440 semantic intact
          INSERT INTO stores (id, name, chain)
          SELECT 440, 'Rimi ePood', 'Rimi'
          WHERE NOT EXISTS (SELECT 1 FROM stores WHERE id=440);

          -- Upsert physical stores (ignore the online row)
          INSERT INTO stores (name, chain, address, lat, lon)
          SELECT s.name, 'Rimi', NULLIF(s.address,''), NULLIF(s.lat,'')::numeric, NULLIF(s.lon,'')::numeric
          FROM staging_rimi_stores s
          WHERE s.name IS NOT NULL AND s.name <> 'Rimi ePood'
          ON CONFLICT (name, chain) DO UPDATE
            SET address = EXCLUDED.address,
                lat      = COALESCE(EXCLUDED.lat, stores.lat),
                lon      = COALESCE(EXCLUDED.lon, stores.lon);

          -- (Lightweight) price aliasing: every Rimi physical store uses 440’s prices
          CREATE TABLE IF NOT EXISTS store_price_alias(
            store_id integer PRIMARY KEY REFERENCES stores(id) ON DELETE CASCADE,
            source_store_id integer NOT NULL REFERENCES stores(id) ON DELETE CASCADE
          );

          -- Keep aliases in sync with current store list
          DELETE FROM store_price_alias
           WHERE store_id IN (SELECT id FROM stores WHERE chain='Rimi' AND id <> 440);

          INSERT INTO store_price_alias(store_id, source_store_id)
          SELECT id, 440
          FROM stores
          WHERE chain='Rimi' AND id <> 440
          ON CONFLICT (store_id) DO UPDATE SET source_store_id = EXCLUDED.source_store_id;

          -- A read-side view that your app can JOIN instead of raw prices
          CREATE OR REPLACE VIEW prices_effective AS
          (
            -- 1) normal prices (stores that don’t alias)
            SELECT pr.product_id, pr.store_id, pr.price
            FROM prices pr
            LEFT JOIN store_price_alias spa ON spa.store_id = pr.store_id
            WHERE spa.store_id IS NULL
          )
          UNION ALL
          (
            -- 2) aliased prices (e.g., every Rimi physical store pulls 440)
            SELECT pr.product_id, spa.store_id AS store_id, pr.price
            FROM store_price_alias spa
            JOIN prices pr ON pr.store_id = spa.source_store_id
          );

          -- Sanity: show how many Rimi physical stores we now have
          SELECT 'rimi_physical_stores' AS what, COUNT(*) AS count
          FROM stores WHERE chain='Rimi' AND id <> 440;

          SQL

      - name: Upload CSV artifact
        uses: actions/upload-artifact@v4
        with:
          name: rimi-stores
          path: out/rimi_stores.csv
